1.
Para responder asumo que sólo tengo la estructura nombrada en su forma más básica, sin variables adicionales.
Buscar (pertenencia):
    - Lista enlazada desordenada O(n) (por necesidad de búsqueda del elemento)
    - Lista enlazada ordenada O(n) (idem desordenada, no se puede hace búsqueda binaria sobre lista enlazada, no se aprovecha el ordenamiento)
    - ABB O(n) (por necesidad de búsqueda en caso de máximo desbalanceo)
    - AVL O(log(n)) (porque la búsqueda en general es O(log(n)))
    - heap binario O(n)
    - trie O(|k|)
Buscar mínimo:
    - Lista enlazada desordenada O(n) (la búsqueda del mínimo requiere "mirar" toda la lista)
    - Lista enlazada ordenada O(1) (si ordenada de menor a mayor, o en cualquier caso si doblemente enlazada)
    - ABB O(n) (por necesidad de búsqueda en caso de máximo desbalanceo)
    - AVL O(log(n)) (por necesidad de iterar sobre los nodos hacia el extremo izquierdo)
    - heap binario O(1) (asumiendo min heap, O(n) si max heap)
    - trie O(1) (es O(longitud máxima de clave), que es O(1) asumiendo que la longitud máxima está acotada; el mínimo es el elemento más a la izquierda)
Borrar mínimo:
    - Lista enlazada desordenada O(n) (por necesidad de búsqueda del mínimo)
    - Lista enlazada ordenada O(1) (si ordenada de menor a mayor, o en cualquier caso si doblemente enlazada)
    - ABB O(n) (por necesidad de búsqueda en caso de máximo desbalanceo, luego el borrado en sí es O(1))
    - AVL O(log(n)) (por necesidad de iterar sobre los nodos hacia el extremo izquierdo y porque la deleción en peor caso (con necesidad de rebalanceo) es O(log(n)))
    - heap binario O(log(n)) (si min heap, desencolar es O(1) y reestructurar es O(log(n)); si max heap O(n) por búsqueda)
    - trie O(1) (asumiendo longitud máxima acotada para las claves)
Insertar (con necesidad de búsqueda): 
    - Lista enlazada desordenada O(n) (por necesidad de búsqueda del elemento a insertar, la inserción en sí es O(1))
    - Lista enlazada ordenada O(n) (idem desordenada, no se puede hace búsqueda binaria sobre lista enlazada, no se aprovecha el ordenamiento)
    - ABB O(n) (por necesidad de búsqueda en caso de máximo desbalanceo)
    - AVL O(log(n)) (porque la búsqueda es O(log(n)) y la inserción en peor caso (con necesidad de rebalanceo) es O(log(n)))
    - heap binario O(n) (insertar en sí es O(log(n)), pero la búsqueda es O(n))
    - trie O(|k|)
Borrar (con necesidad de búsqueda):
    - Lista enlazada desordenada O(n) (por necesidad de búsqueda del elemento a borrar, la deleción en sí es O(1))
    - Lista enlazada ordenada O(n) (idem desordenada, no se puede hace búsqueda binaria sobre lista enlazada, no se aprovecha el ordenamiento)
    - ABB O(n) (por necesidad de búsqueda en caso de máximo desbalanceo, luego el borrado en sí es O(1))
    - AVL O(log(n)) (porque la búsqueda es O(log(n)) y la deleción en peor caso (con necesidad de rebalanceo) es O(log(n)))
    - heap binario O(n) (borrar en sí es O(log(n)), pero la búsqueda es O(n))
    - trie O(|k|)

2.1.no ordenadas.
proc union(inout l1: ListaEnlazada<T>, in l2: ListaEnlazada<T>) { // l1 de largo n, l2 de largo m
    Iterador<ListaEnlazada<T>> iterador1 = new Iterador<ListaEnlazada<T>>; // O(1)
    Iterador<ListaEnlazada<T>> iterador2 = new Iterador<ListaEnlazada<T>>; // O(1)
    iterador2 = l2.iterador(); // O(1)
    while (iterador2.haySiguiente()) { // O(1)
        T elem2 = iterador2.siguiente(); // O(1)
        bool pertenece = false; // O(1)
        iterador1 = l1.iterador(); // O(1)
        while (iterador1.haySiguiente && !pertenece) { // O(1)
            T elem1 = iterador1.siguiente(); // O(1)
            if (elem1 == elem2) { // O(1)
                pertenece = true; // O(1)
            }
        } // O(n)
        if (!pertenece) { // O(1)
            l1.agregarAtrás(elem2); // O(cp(T))
        }
    } // O((n + cp(T))*m)
} // O((n + cp(T))*m)

proc interseccion(in l1, l2: ListaEnlazada<T>, out l: ListaEnlazada<T>) { // l1 de largo n, l2 de largo m
    ListaEnlazada<T> l = new ListaEnlazada<T>; // O(1)
    l = listaVacía(); // O(1)
    Iterador<ListaEnlazada<T>> iterador1 = new Iterador<ListaEnlazada<T>>; // O(1)
    Iterador<ListaEnlazada<T>> iterador2 = new Iterador<ListaEnlazada<T>>; // O(1)
    iterador2 = l2.iterador(); // O(1)
    while (iterador2.haySiguiente()) { // O(1)
        T elem2 = iterador2.siguiente(); // O(1)
        bool pertenece = false; // O(1)
        iterador1 = l1.iterador(); // O(1)
        while (iterador1.haySiguiente && !pertenece) { // O(1)
            T elem1 = iterador1.siguiente(); // O(1)
            if (elem1 == elem2) { // O(1)
                pertenece = true; // O(1)
            }
        } // O(n)
        if (pertenece) { // O(1)
            l.agregarAtrás(elem2); // O(cp(T))
        }
    } // O((n + cp(T))*m)
    return l; // O(1)
} // O((n + cp(T))*m)

2.1.ordenadas (de menor a mayor).
proc union(in l1, l2: ListaEnlazada<T>, out l: ListaEnlazada<T>) { // l1 de largo n, l2 de largo m
    ListaEnlazada<T> l = new ListaEnlazada<T>; // O(1)
    l = listaVacía(); // O(1)
    Iterador<ListaEnlazada<T>> iterador1 = new Iterador<ListaEnlazada<T>>; // O(1)
    Iterador<ListaEnlazada<T>> iterador2 = new Iterador<ListaEnlazada<T>>; // O(1)
    iterador1 = l2.iterador(); // O(1)
    iterador2 = l2.iterador(); // Ö(1)
    bool hayElems = false; // O(1)

    if (iterador1.haySiguiente() && iterador2.haySiguiente()) { // O(1)
        T elem1 = iterador1.siguiente(); // O(1)
        T elem2 = iterador2.siguiente(); // O(1)
        hayElems = true; // O(1)
    }

    while (iterador1.haySiguiente() && iterador2.haySiguiente()) { // O(1)
        if (elem1 < elem2) { // O(ord(T))
            l.agregarAtrás(elem1); // O(cp(T))
            elem1 = iterador1.siguiente(); // O(1) // quedan elems de l2 y último de l1
        } else if (elem1 > elem2) { // O(ord(T))
            l.agregarAtrás(elem2); // O(cp(T))
            elem2 = iterador2.siguiente(); // O(1) // quedan elems de l1 y último de l2
        } else {
            l.agregarAtrás(elem1); // O(cp(T))
            elem1 = iterador1.siguiente(); // O(1)
            elem2 = iterador2.siguiente(); // O(1) // quedan elems de l2 y último de l1, elems de l1 y último de l2, o los dos últimos de ambas
        }
    } // O(max{n,m}*(ord(T) + cp(T)))

    if (hayElems && !iterador1.haySiguiente() && !iterador2.haySiguiente()) { // O(1) // caso: quedaron los dos últimos de ambas
        if (elem1 < elem2) { // O(ord(T))
            l.agregarAtrás(elem1); // O(cp(T))
        } else {
            l.agregarAtrás(elem2); // O(cp(T))
        }
    }

    if (iterador1.haySiguiente()) { // O(1) // caso: quedan elems de l1 y último de l2, o l2 nunca tuvo elems
        while (iterador1.haySiguiente() { // O(1)
            if (hayElems && elem2 < elem1) { // O(ord(T))
                l.agregarAtrás(elem2); // O(cp(T))
                hayElems = false; // O(1)
            } else {
                l.agregarAtrás(elem1); // O(cp(T))
                elem1 = iterador1.siguiente(); // O(1)
            }
        } // O(n*(cp(T) + ord(T)))
        if (hayElems) { // O(1)
            if (elem1 < elem2) { // O(ord(T))
                l.agregarAtrás(elem1); // O(cp(T))
                l.agregarAtrás(elem2); // O(cp(T))
            } else {
                l.agregarAtrás(elem2); // O(cp(T))
                l.agregarAtrás(elem1); // O(cp(T))
            }
        } else {
            l.agregarAtrás(elem1); // O(cp(T))
        }
    }

    if (iterador2.haySiguiente()) { // O(1) // caso: quedan elems de l2 y último de l1, o l1 nunca tuvo elems
        while (iterador2.haySiguiente() { // O(1)
            if (hayElems && elem1 < elem2) { // O(ord(T))
                l.agregarAtrás(elem1); // O(cp(T))
                hayElems = false; // O(1)
            } else {
                l.agregarAtrás(elem2); // O(cp(T))
                elem2 = iterador2.siguiente(); // O(1)
            }
        } // O(m*(cp(T) + ord(T)))
        if (hayElems) { // O(1)
            if (elem2 < elem1) { // O(ord(T))
                l.agregarAtrás(elem2); // O(cp(T))
                l.agregarAtrás(elem1); // O(cp(T))
            } else {
                l.agregarAtrás(elem1); // O(cp(T))
                l.agregarAtrás(elem2); // O(cp(T))
            }
        } else {
            l.agregarAtrás(elem2); // O(cp(T))
        }
    }
    return l; // O(1)
} // O(max{n, m}*(ord(T) + cp(T))) == O((n + m)*(ord(T) + cp(T)))

proc interseccion(in l1, l2: ListaEnlazada<T>, out l: ListaEnlazada<T>) { // l1 de largo n, l2 de largo m
    ListaEnlazada<T> l = new ListaEnlazada<T>; // O(1)
    l = listaVacía(); // O(1)
    Iterador<ListaEnlazada<T>> iterador1 = new Iterador<ListaEnlazada<T>>; // O(1)
    Iterador<ListaEnlazada<T>> iterador2 = new Iterador<ListaEnlazada<T>>; // O(1)
    iterador1 = l2.iterador(); // O(1)
    iterador2 = l2.iterador(); // O(1)
    bool hayElems = false; // O(1)

    if (iterador1.haySiguiente() && iterador2.haySiguiente()) { // O(1)
        T elem1 = iterador1.siguiente(); // O(1)
        T elem2 = iterador2.siguiente(); // O(1)
        hayElems = true; // O(1)
    }

    while (iterador1.haySiguiente() && iterador2.haySiguiente()) { // O(1)
        if (elem1 < elem2) { // O(ord(T))
            elem1 = iterador1.siguiente(); // O(1) // quedan elems de l2 y último de l1
        } else if (elem1 > elem2) { // O(ord(T))
            elem2 = iterador2.siguiente(); // O(1) // quedan elems de l1 y último de l2
        } else {
            l.agregarAtrás(elem1); // O(cp(T))
            elem1 = iterador1.siguiente(); // O(1)
            elem2 = iterador2.siguiente(); // O(1) // quedan elems de l2 y último de l1, elems de l1 y último de l2, o los dos últimos de ambas
        }
    } // O(max{n,m}*(ord(T) + cp(T)))

    if (hayElems && !iterador1.haySiguiente() && !iterador2.haySiguiente()) { // O(1) // caso: quedaron los dos últimos de ambas
        if (elem1 == elem2) { // O(eq(T))
            l.agregarAtrás(elem1); // O(cp(T))
        }
    }

    if (iterador1.haySiguiente()) { // O(1) // caso: quedan elems de l1 y último de l2, o l2 nunca tuvo elems
        while (iterador1.haySiguiente() { // O(1)
            if (hayElems && elem2 == elem1) { // O(eq(T))
                l.agregarAtrás(elem1); // O(cp(T))
                hayElems = false; // O(1)
            } else {
                elem1 = iterador1.siguiente(); // O(1)
            }
        } // O(n*(cp(T) + eq(T)))
        if (hayElems) { // O(1)
            if (elem1 == elem2) { // O(eq(T))
                l.agregarAtrás(elem1); // O(cp(T))
            }
        }
    }

    if (iterador2.haySiguiente()) { // O(1) // caso: quedan elems de l2 y último de l1, o l1 nunca tuvo elems
        while (iterador2.haySiguiente() { // O(1)
            if (hayElems && elem1 == elem2) { // O(eq(T))
                l.agregarAtrás(elem2); // O(cp(T))
                hayElems = false; // O(1)
            } else {
                elem2 = iterador2.siguiente(); // O(1)
            }
        } // O(n*(cp(T) + eq(T)))
        if (hayElems) { // O(1)
            if (elem2 == elem1) { // O(eq(T))
                l.agregarAtrás(elem2); // O(cp(T))
            }
        }
    }
    return l; // O(1)
} // O(max{n, m}*(ord(T) + cp(T) + eq(T))) == O((n + m)*(ord(T) + cp(T) + eq(T)))

/* obs.: no se pedía ninguna cota de complejidad, así que podría haber hecho algo MUCHO más simplificado usando los métodos ya dados por el apunte... */

2.2. // complejidades basadas en la implementación que tengo hecha del TP de ABB
proc union(inout a1, a2: ABB<T>) {
    Iterador<ABB<T>> iterador1 = new Iterador<ABB<T>>; // O(1)
    iterador1 = a1.iterador(); // O(n) // inicializar requiere llamar a ._buscar_nodo() y .minimo() en sucesión, ambas O(n)
    while (iterador1.haySiguiente()) { // O(1) // en mi extraña implementación, .haySiguiente() sólo chequea que el nodo actual no sea null
        T elem = iterador1.siguiente(); // O(n) // .siguiente() tiene cota O(n) por llamar a ._buscar_nodo()
        a1.eliminar(elem); // O(n) // .eliminar() es O(n) por llamar a ._buscar_nodo() // innecesario, pero libera memoria
        a2.insertar(elem); // O(n) // .insertar() es O(n) por llamar a ._buscar_nodo()
    } // O(n**2)
} // O(n**2)

proc interseccion(inout a1: ABB<T>, in a2: ABB<T>) {
    Iterador<ABB<T>> iterador1 = new Iterador<ABB<T>>; // O(1)
    iterador1 = a1.iterador(); // O(n)
    while (iterador1.haySiguiente()) { // O(1)
        T elem = iterador1.siguiente(); // O(n)
        if (!a2.pertenece(elem)) { // O(n) // la búsqueda con .pertenece(), como es esperable, es O(n)
            a1.eliminar(elem); // O(n)
        }
    } // O(n**2)
} // O(n**2)

2.3. // asumo implementación de heap sobre array para los fines de determinar la complejidad asociada al iterador
proc union(inout h1, h2: Heap<T>) {
    Iterador<Heap<T>> iterador1 = new Iterador<Heap<T>>; // O(1)
    iterador1 = h1.iterador(); // O(1)
    while (iterador1.haySiguiente()) { // O(1)
        T elem = iterador1.siguiente(); // O(1) // acceso a array
        a1.eliminar(elem); // O(log(n))
        a2.insertar(elem); // O(log(n))
    } // O(n*log(n))
} // O(n*log(n))

proc interseccion(inout h1: Heap<T>, in h2: Heap<T>) {
    Iterador<Heap<T>> iterador1 = new Iterador<Heap<T>>; // O(1)
    iterador1 = h1.iterador(); // O(1)
    while (iterador1.haySiguiente()) { // O(1)
        T elem = iterador1.siguiente(); // O(1)
        if (!h2.pertenece(elem)) { // O(n) // la búsqueda es O(n)
            h1.eliminar(elem); // O(log(n))
        }
    } // O(n**2)
} // O(n**2)

3.
Módulo matrizInfinitaImpl implementa TAD Matriz infinita de booleanos {
    var elems: Array<Array<bool>>;
    var complemento: bool;

    /* obs.: el proc asignar, del que no se pide nada, se encarga de redimensionar a elems */

    proc crear(out m: matrizInfinitaImpl) {
        matrizInfinitaImpl m = new matrizInfinitaImpl; // O(1)
        Array<bool> fila = new Array<bool>[0]; // O(1)
        fila = []; // O(1)
        Array<Array<bool>> matriz = new Array<Array<bool>>[0][0]; // O(1)
        matriz = [fila]; // O(1)
        m.elems = matriz; // O(1)
        m.complemento = false; // O(1)
    } // O(1)

    proc ver(in m: matrizInfinitaImpl, in fila, columna: int, out res: bool) {
        bool res = m.elems[fila][columna]; // O(1)
        if (complemento) { // O(1)
            res = !res; // O(1)
        }
        return res; // O(1)
    } // O(1)

    proc complementar(inout m: matrizInfinitaImpl) {
        m.complemento = !m.complemento; // O(1)
    } // O(1)
}

4. // asumo que T es numerico y que la matriz se inicializa con ceros
Módulo matrizFinitaImpl<T> implementa TAD Matriz finita<T> {
    var nFilas: int;
    var nColumnas: int;
    var elems: ListaEnlazada<struct<valor: T, fila: int, columna: int>>; // doblemente enlazada

    proc definir(inout A: matrizFinitaImpl<T>, in fila, columna: int, in nuevoValor: T) { // asumo que la posición es valida como parte del requiere implicito, y que nuevoValor es distinto de 0
        Iterador<ListaEnlazada<...>> iterador = new Iterador<ListaEnlazada<...>>; // Θ(1)
        iterador = A.elems.iterador(); // Θ(1)
        struct<...> nuevoElem = new struct<...>; // Θ(1)
        nuevoElem = struct<valor: nuevoValor, fila: fila, columna: columna>; // Θ(1)
        bool definido = false; // Θ(1)
        while (iterador.haySiguiente() && !definido) { // Θ(1)
            struct<...> elem = iterador.siguiente(); // Θ(1)
            if fila < elem.fila || (fila == elem.fila && columna < elem.columna) { // Θ(1)
                A.elems.agregarAdelante(nuevoElem); // Θ(1) // Θ(1) porque no es el .agregarAdelante() convencional, si no a partir de la posición actual del iterador
                definido = true; // Θ(1)
            } else if (fila == elem.fila && columna == elem.columna) { // Θ(1) // asumo O(eq(T)) constante
                elem.valor = nuevoValor; // Θ(1) // actualiza la lista por aliasing
                definido = true; // Θ(1)
            }
        } // Θ(n)
        if (!definido) { // Θ(1)
            A.elems.agregarAtrás(nuevoElem); // Θ(1) // Θ(1) porque no es el .agregarAtrás() convencional, si no a partir de la posición actual del iterador
        }
    } // Θ(n)

    proc obtener(in A: matrizFinitaImpl<T>, in fila, columna: int, out res: T) {
        T res = 0; // Θ(1)
        Iterador<ListaEnlazada<...>> iterador = new Iterador<ListaEnlazada<...>>; // Θ(1)
        iterador = A.elems.iterador(); // Θ(1)
        while (iterador.haySiguiente()) { // Θ(1)
            struct<...> elem = iterador.siguiente(); // Θ(1)
            if (elem.fila == fila && elem.columna == columna) { // Θ(1)
                res = elem.valor; // Θ(1)
            }
        } // Θ(n)
        return res; // Θ(1)
    } // Θ(n)

    proc sumarMatrices(in A, B: matrizFinitaImpl<T>, out C: matrizFinitaImpl<T>) { // merge
        int filas = A.nFilas; // Θ(1)
        int columnas = A.nColumnas; // Θ(1)
        matrizFinitaImpl<T> C = new matrizFinitaImpl<T>; // Θ(1)
        C = crear(filas, columnas); // O(1)
        struct<...> nuevoElem = new struct<...>; // Θ(1)
        
        Iterador<ListaEnlazada<...>> iteradorA = new Iterador<ListaEnlazada<...>>; // Θ(1)
        Iterador<ListaEnlazada<...>> iteradorB = new Iterador<ListaEnlazada<...>>; // Θ(1)
        iteradorA = A.elems.iterador(); // Θ(1)
        iteradorB = B.elems.iterador(); // Θ(1)

        if (!iteradorA.haySiguiente()) {
            C.elems.concatenar(B.elems); // Θ(n + m), n = 0
            return C; // Θ(1)
        }
        if (!iteradorB.haySiguiente()) {
            C.elems.concatenar(A.elems); // Θ(n + m), m = 0
            return C; // Θ(1)
        }

        struct<...> elemA = A.elems.primero(); // Θ(1)
        struct<...> elemB = B.elems.primero(); // Θ(1)
        bool hayProxA = true; // Θ(1)
        bool hayProxB = true; // Θ(1)

        while (hayProxA || hayProxB) { // Θ(1)
            hayProxA = iteradorA.haySiguiente(); // Θ(1)
            hayProxB = iteradorB.haySiguiente(); // Θ(1)

            if (elemA.fila == elemB.fila && elemA.columna == elemB.columna) { // Θ(1)
                nuevoElem = struct<valor: elemA.valor + elemB.valor, fila: fila, columna: columna>; // Θ(1)
                C.elems.agregarAtrás(nuevoElem); // Θ(1)
                if (hayProxA) { // Θ(1)
                    elemA = iteradorA.siguiente(); // Θ(1)
                } 
                if (hayProxB) { // Θ(1)
                    elemB = iteradorA.siguiente(); // Θ(1)
                } 
                if (!hayProxA && !hayProxB) { // Θ(1)
                    return C; // Θ(1)
                }
            }

            if (elemA.fila < elemB.fila || (elemA.fila == elemB.fila && elemA.columna < elemB.columna)) {  // Θ(1)
                C.elems.AgregarAtrás(elemA); // Θ(1)
                if (hayProxA) { // Θ(1)
                    elemA = iteradorA.siguiente(); // Θ(1)
                } else {
                    C.elems.AgregarAtrás(elemB); // Θ(1)
                    while (iteradorB.haySiguiente()) { // Θ(1)
                        elemB = iteradorB.siguiente(); // Θ(1)
                        C.elems.AgregarAtrás(elemB); // Θ(1)
                    } // Θ(m - n) con m > n
                    return C; // Θ(1)
                }
            }

            if (elemB.fila < elemA.fila || (elemB.fila == elemA.fila && elemB.columna < elemA.columna)) {  // Θ(1)
                C.elems.AgregarAtrás(elemB); // Θ(1)
                if (hayProxB) { // Θ(1)
                    elemB = iteradorB.siguiente(); // Θ(1)
                } else {
                    C.elems.AgregarAtrás(elemA); // Θ(1)
                    while (iteradorA.haySiguiente()) { // Θ(1)
                        elemA = iteradorA.siguiente(); // Θ(1)
                        C.elems.AgregarAtrás(elemA); // Θ(1)
                    } // Θ(n - m) con n > m
                    return C; // Θ(1)
                }
            }
        } // Θ(n + m)
    } // Θ(n + m)
}

5.
Módulo DCH<K, V> implementa TAD DiccionarioConHistoria<K, V> { // complejidades dadas asumiendo O(eq(K)) == O(cp(k)) == O(cp(v)) == O(1)
    var data: DiccionarioLineal<K, V>;
    var cant: DiccionarioLineal<K, int>;

    proc nuevoDiccionario(out res: DCH<K, V>) {
        DCH<K, V> res = new DCH<K, V>; // O(1)
        res.data = diccionarioVacío(); // O(1)
        res.cant = diccionarioVacío(); // O(1)
        return res; // O(1)
    } // O(1)

    proc está(in d: DCH<K, V>, in k: K, out res: bool) {
        bool res = false; // O(1)
        Iterador<DiccionarioLineal<K, V>> it = Iterador<new DiccionarioLineal<K, V>>; // O(1)
        it = d.data.iterador(); // O(1)
        while(!res && it.hay_siguiente()) { // O(1)
            <K, V> <clave, _> = it.siguiente(); // O(1), considero que .siguiente(), además de devolver el próximo valor, avanza el iterador
            res = clave == k; // O(1)
        } // O(n)
    } // O(n)

    proc obtener(in d: DCH<K, V>, in k: K, out res: V) { // requiere que k esté en d.data, podría haberse simplemente usado d.data.obtener() de DiccionarioLineal
        bool buscando = true; // O(1)        
        Iterador<DiccionarioLineal<K, V>> it = Iterador<new DiccionarioLineal<K, V>>; // O(1)
        it = d.data.iterador(); // O(1)
        while(buscando && it.hay_siguiente()) { // O(1)
            <K, V> <clave, res> = it.siguiente(); // O(1), considero que .siguiente(), además de devolver el próximo valor, avanza el iterador
            buscando = clave != k; // O(1)
        } // O(n)
        return res; // O(1)
    } // O(n)

    proc definir(inout d: DCH<K, V>, in k: K, in v: V) {
        if (!está(d, k)) { // O(n)
            d.data.definir_rapido(k, v); // O(1)
            d.cant.definir_rapido(k, 1); // O(1)
        } else {
            d.data.definir(k, v); // O(n)
            cantidad = d.cant.obtener(k) + 1; // O(n)
            d.cant.definir(k, cantidad); // O(n)
        }
    } // O(n)

    proc borrar(inout d: DCH<K, V>, in k: K, out v: V) { // requiere que k esté en d.data
        res = d.obtener(k); // O(n)
        d.data.borrar(k); // O(n)
        return res; // O(1)
    } // O(n)

    proc cant_significados(in d: DCH<K, V>, in k: K, out res: int) {
        return d.cant.obtener(k); // O(n)
    } // O(n)
}

6. // complejidades dadas asumiendo que comparar nodos y sus valores de tipo T es O(1)
proc esCamino(in a: AB<T>, in s: Array<Nodo>, out res: bool) {
    if (s.length == 0) { // O(1)
        res = true; // O(1)
    } else {
        res = s[0] = a.raiz && s[s.length-1].izq == s[s.length-1].der == null; // O(1)
        int i = 0; // O(1)
        while (res && i < s.length-1) { // O(1)
            res &= s[i].izq == s[i+1].izq || s[i].der == s[i+1].der; // O(1)
        } // O(|s|)
    }
    return res; // O(1)
} // O(|s|)

proc hayCaminoDeAltura(in a: AB<T>, in n: int, out res: bool) {
    // DFS pre-order (de raiz a izquierda a derecha)
    bool res; // O(1)
    if (n >= 1 && a.raiz = null) { // O(1)
        res = false; // O(1)
    } else if (n == 1) { // O(1)
        res = a.raiz.izq == a.raiz.der == null; // O(1)
    } else {
        res = hayCaminoDeAltura(a.raiz.izq, n-1) || hayCaminoDeAltura(a.raiz.der, n-1); // recursión
    }
    return res; // O(1)
} // no estoy para nada seguro de cual sería la mejor cota, pero estoy seguro de que puede acotarse por O(|a|)

proc nivelCompleto(in a: AB<T>, in n: int, out res: bool) {
    // DFS pre-order (de raiz a izquierda a derecha)
    bool res; // O(1)
    if (n >= 1 && a.raiz = null) { // O(1)
        res = false; // O(1)
    else if (n == 1) { // O(1)
        res = true; // O(1)
    else {
        res = nivelCompleto(a.raiz.izq, n-1) && nivelCompleto(a.raiz.der, n-1); // recursión
    }
    return res; // O(1)
} // nuevamente, al ser una DFS, puede ser acotado por O(|a|)

proc estaCompleto(in a: AB<T>, out res: bool) {
    int i = 0; // O(1)    
    while (nivelCompleto(a, i)) { // O(|a|)
        i++; // O(1)
    } // O(|a|**2)
    res !hayCaminoDeAltura(a, i+1); // O(|a|)
    return res; // O(1)
} // seguramente exista una mejor cota, pero aún más seguramente una cota válida es O(|a|**2)

7.1. /* DUDA */

7.2. 
Ver TP2.

8.1.
Módulo cojuntoMinMax<int> implementa TAD Conjunto<Nat> {
    var elems: ListaEnlazada<int>; // siempre se mantiene ordenada
    var min: int; // se inicializa como -1 y se actualiza al agregar elementos
    var max: int; // idem min

    proc agregar(inout c: conjuntoMinMax<int>, in elem: int) {
        if (elem > c.max) { // O(1)
            c.elems.agregar_atrás(elem); // O(cp(int)) == O(1)
            c.max = elem; // O(1)
        } else if (elem < c.min) {
            c.elems.agregar_adelante(elem); // O(cp(int)) == O(1)
            c.min = elem; // O(1)
        } else {
            c.elems.agregar_en_orden(elem); // O(n), asumo que ListaEnlazada<T> tiene implementado este proc que permite, con una sola pasada sobre la lista, agregar al elemento en la posición que le corresponde tal que se preserve el orden
        }
    } // O(1) si elem es nuevo max o min, O(n) si no

    // asumo que el iterador tiene, además de .siguiente(), .avanzar(); .siguiente() sólo da el próximo elemento sin avanzar el iterador, .avanzar() lo avanza
    // tanto .siguiente() como .avanzar() son O(1) dado que conjuntoLineal<T> se implementa sobre ListaEnlazada<T>
    proc union(inout c1: conjuntoMinMax<int>, in c2: conjuntoMinMax<int>) {
        if (c2.min > c1.max) { // O(1)
            c1.elems = c1.elems.concatenar(c2.elems); // O(m)
            if (c2.max != -1) { // O(1)
                c1.max = c2.max; // O(1)
            }
        } else if (c1.min > c2.max) { // O(1)
            c1.elems = c1.concatenar_adelante(c2.elems); // O(m), asumo que tengo una versión de concatenar que invierte el orden en el que se concatenan las listas
            if (c2.min != -1) { // O(1)
                c1.min = c2.min; // O(1)
            }
        } else { // merge
            Iterador<ListaEnlazada<int>> it1 = new Iterador<ListaEnlazada<int>>; // O(1)
            Iterador<ListaEnlazada<int>> it2 = new Iterador<ListaEnlazada<int>>; // O(1)
            it1 = c1.elems.iterador(); // O(1)
            it2 = c2.elems.iterador(); // O(1)
            if (!it1.hay_siguiente()) { // O(1)
                c1 = c2; // O(m), copia completa
            } else if (it1.hay_siguiente() && it2.hay_siguiente()) { // O(1)
                while (it1.hay_siguiente() && it2.hay_siguiente()) { // O(1)
                    elem1 = it1.siguiente(); // O(1), no avanza
                    elem2 = it2.siguiente();
                    if (elem1 == elem2) { // O(1)
                        it1.avanzar(); // O(1)
                        it2.avanzar(); // O(1)
                    } else if (elem1 < elem2) { // O(1)
                        it1.avanzar()
                    } else { // elem1 > elem2
                        c1.elems.agregar_anterior(it1, elem2); // O(1), asumo que existe proc para insertar a la izquierda de donde está parado un dado iterador, no avanza el iterador
                        it2.avanzar();
                    }
                } // O(n + m)
                // si se salió del loop, es o porque se depletó c1.elems o c2.elems; en el segundo caso ya se terminó pero en el primero hay que recorrer el resto de los elementos de c2.elems y agregarlos a c1
                while (it2.hay_siguiente()) { // O(1)
                    c1.elems.agregar_atras(it2.siguiente()); // O(1)
                    it2.avanzar(); // O(1)
                } // O(m)
                // por último, se deben setear correctamente min y max
                c1.max = c1.elems.ultimo(); // O(1)
                c1.min = c1.elems.primero(); // O(1)
            }
        }
    } // O(1) o O(n + m) según el caso

    proc interseccion(inout c1: conjuntoMinMax<int>, in c2: conjuntoMinMax<int>) {
        if (c1.min > c2.max || c2.min > c1.max) { // O(1)
            c1.elems = lista_vacía(); // O(1)
            c1.min = -1; // O(1)
            c1.max = -1; // O(1)
        } else { // merge
            Iterador<ListaEnlazada<int>> it1 = new Iterador<ListaEnlazada<int>>; // O(1)
            Iterador<ListaEnlazada<int>> it2 = new Iterador<ListaEnlazada<int>>; // O(1)
            it1 = c1.elems.iterador(); // O(1)
            it2 = c2.elems.iterador(); // O(1)
            if (!it1.hay_siguiente()) { // O(1)
                c1 = c2; // O(m), copia completa
            } else if (it1.hay_siguiente() && it2.hay_siguiente()) { // O(1)
                while (it1.hay_siguiente() && it2.hay_siguiente()) { // O(1)
                    elem1 = it1.siguiente(); // O(1), no avanza
                    elem2 = it2.siguiente();
                    if (elem1 == elem2) { // O(1)
                        it1.avanzar(); // O(1)
                        it2.avanzar(); // O(1)
                    } else if (elem1 < elem2) { // O(1)
                        c1.elems.borrar_siguiente(it1); // O(1), asumo que existe proc para borrar donde está parado un dado iterador, implicitamente avanza el iterador
                    } else { // elem1 > elem2
                        it2.avanzar();
                    }
                } // O(n + m)
                // si se salió del loop, es o porque se depletó c1.elems o c2.elems; en el primer caso ya se terminó pero en el segundo hay que borrar el resto de los elementos de c1.elems
                while (it1.hay_siguiente()) { // O(1)
                    c1.elems.borrar_siguiente(it1); // O(1)
                } // O(n)
                // por último, se deben setear correctamente min y max
                c1.max = c1.elems.ultimo(); // O(1)
                c1.min = c1.elems.primero(); // O(1)
            }
        }
    } // O(1) o O(n + m) según el caso
}

8.2.
El tipo debe ser ordenable, los costos de copia y comparación deben ser O(1) y, 
dado el diseño específicamente utilizado, debe haber al menos un elemento del tipo que pueda ser reservado para denotar la no existencia de mínimo o máximo 
(como el -1 en el caso de los naturales, implementados con el tipo int).

9.1.
Módulo Relaciones_0_100 implementa TAD Relaciones { // basado en matrizInfinitaImpl, ej. 3.
    var pares: Array<Array<bool>>;

    proc crear(out r: Relaciones_0_100) {
        Relaciones_0_100 r = new Relaciones_0_100; // O(1)
        Array<Array<bool>> matriz = new Array<Array<bool>>[101][101]; // O(1)
        r.pares = matriz; // O(1)
        return r; // O(1)
    } // O(1)

    proc agregar_pareja(inout r: Relaciones_0_100, in a: int, in b: int) { // agrega aRb
        r.pares[a][b] = true; // O(1)
    } // O(1)

    proc borrar_pareja(inout r: Relaciones_0_100, in a: int, in b: int) { // borra aRb
        r.pares[a][b] = false; // O(1)
    } // O(1)

    proc b_tq_aRb(in r: Relaciones_0_100, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        for (int b = 0; b <= 100; b++) { // O(1)
            if (r[a][b]) { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(1)
    } // O(1)

    proc b_tq_bRA(in r: Relaciones_0_100, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        for (int b = 0; b <= 100; b++) { // O(1)
            if (r[b][a]) { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(1)
    } // O(1)
}

9.2.
Módulo Relaciones_rango implementa TAD Relaciones { // basado en matrizInfinitaImpl, ej. 3.
    var pares: Array<Array<bool>>;
    var min: int;
    var max: int; // inclusive

    proc crear(out r: Relaciones_rango, in min: int, in max: int) {
        Relaciones_rango r = new Relaciones_rango; // O(1)
        Array<Array<bool>> matriz = new Array<Array<bool>>[max-min+1][max-min+1]; // O((max-min+1)**2)
        r.pares = matriz; // O(1)
        return r; // O(1)
    } // O((max-min+1)**2)

    proc agregar_pareja(inout r: Relaciones_rango, in a: int, in b: int) { // agrega aRb
        r.pares[a-min][b-min] = true; // O(1)
    } // O(1)

    proc borrar_pareja(inout r: Relaciones_rango, in a: int, in b: int) { // borra aRb
        r.pares[a-min][b-min] = false; // O(1)
    } // O(1)

    proc b_tq_aRb(in r: Relaciones_rango, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        for (int b = min; b <= max; b++) { // O(1)
            if (r[a-min][b-min]) { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(1)
    } // O(1)

    proc b_tq_bRA(in r: Relaciones_rango, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        for (int b = min; b <= max; b++) { // O(1)
            if (r[b-min][a-min]) { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(1)
    } // O(1)
}

9.3.
// Agregar a una matriz redimensionable podría ser demasiado costoso, podría ser preferible una estructura de árbol.

Módulo Relaciones implementa TAD Relaciones {
    var pares: ConjuntoLog<<int, int>>;

    proc crear(out r: Relaciones) {
        Relaciones r = new Relaciones(); // O(1)
        ConjuntoLog<<int, int>> c = new ConjuntoLog<<int, int>>; // O(1)
        c = conj_vacío(); // O(1)
        r.pares = c; // O(1)
        return r; // O(1)
    }

    proc agregar_pareja(inout r: Relaciones, in a: int, in b: int) { // agrega aRb
        if (!r.pares.pertenece(<a, b>)) { // O(log(n))
            r.pares.agregar_rapido(<a, b>); // O(log(n))
        }
    } // O(log(n))

    proc borrar_pareja(inout r: Relaciones, in a: int, in b: int) { // agrega aRb
        r.pares.sacar(<a, b>); // O(log(n))
    } // O(log(n))

    proc b_tq_aRb(in r: Relaciones, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        Iterador<ConjuntoLog<<int, int>>> it = new Iterador<ConjuntoLog<<int, int>>>; // O(1)
        it = r.pares.iterador(); // O(1)
        
        while (it.hay_siguiente()) {
            <int, int> <a', b> = it.siguiente();
            if (a == a') { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(n)
    } // O(n)

    proc b_tq_bRa(in r: Relaciones, in a: int, out res: ListaEnlazada<int>) {
        ListaEnlazada<int> res = new ListaEnlazada<int>; // O(1)
        res = lista_vacía(); // O(1)
        Iterador<ConjuntoLog<<int, int>>> it = new Iterador<ConjuntoLog<<int, int>>>; // O(1)
        it = r.pares.iterador(); // O(1)
        
        while (it.hay_siguiente()) {
            <int, int> <b, a'> = it.siguiente();
            if (a == a') { // O(1)
                res.agregar_atrás(b); // O(1)
            }
        } // O(n)
    } // O(n)
}

10.1, 4.
Modulo IngresosAlBancoImpl implementa TAD IngresosAlBanco {
	var totales_acumulados: Array<int>; 

	...
	
	proc mediana(in i: IngresosAlBancoImpl, out d: int) {
		n = i.totales_acumulados.length;
		for d = n-1..0 inclusive {
			if (cantPersonas(i, 1, d) <= cantPersonas(i, d+1, totDias(i))) {
				return d;
			}
		}
	}
}

10.2, 3.
El tamaño de la estructura es función lineal 1 a 1 de la cantidad de días transucrridos.

11.1, 2, 3, 4, 5.
Modulo TextoImpl implementa TAD Texto {
    var palabras: Vector<Palabra>; // el texto en sí
    var posiciones_por_palabra: DictTrie<Palabra, ConjuntoLineal<int>>; // palabra, conjunto de posiciones
    var repeticiones_maxima: int;
    var palabras_mas_repetidas: ConjuntoTrie<Palabra>;
    var largo: int;
    
    pred InvRep(t: TextoImpl) {
        // toda palabra en palabras está en posiciones_por_palabra y viceversa
        forall i: Z :: 0 <= i < t.largo =>L t.palabras[i] in t.posiciones_por_palabra
        forall p: Palabra :: p in t.posiciones_por_palabra =>L p in t.palabras[0..largo-1]
        // las palabras de posiciones_por_palabra están en palabras en las posiciones indicadas, y todas las posiciones están entre 0 y largo-1
        forall p: Palabra :: p in t.posiciones_por_palabra =>L
            forall i: Z :: i in t.posiciones_por_palabra[p] =>L 0 <= i < t.largo ^L t.palabras[i] == p
        // largo es la suma de las longitudes de todos los conjuntos de posiciones_por_palabra
        t.largo = sum :: p in t.posiciones_por_palabra :: |t.posiciones_por_palabra[p]|
        // todas las palabras en palabras_mas_repetidas tienen conjunto de repeticiones_maxima elementos
        forall p: Palabra :: p in t.palabras_mas_repetidas <=> (p in t.posiciones_por_palabra ^L |t.posiciones_por_palabra[p]| == t.repeticiones_maxima)
        // repeticiones_maxima es el maximo de las longitudes en t.posiciones_por_palabra
        exists p: Palabra :: p in t.posiciones_por_palabra ^L |t.posiciones_por_palabra[p]| == t.repeticiones_maxima
        !exists p: Palabra :: p in t.posiciones_por_palabra ^L |t.posiciones_por_palabra[p]| > t.repeticiones_maxima
        // no hay posiciones repetidas entre los conjuntos de posiciones_por_palabra (por invariante de conjunto, tampoco dentro de cada uno)
        forall p: Palabra :: p in t.posiciones_por_palabra =>L 
            forall i: int :: i in t.posiciones_por_palabra[p] =>L 
                !exists p': Palabra :: (p' != p ^ p' in t.posiciones_por_palabra) ^L i in t.posiciones_por_palabra[p']
    }

    FuncAbs(in t': TextoImplt, out t: Texto) {
        t: Texto |
        t.palabras == t'.palabras[0..t'.largo-1] // mismas palabras, mismo orden
    }

    proc cambiarPalabra(inout t: TextoImpl, in vieja, nueva: Palabra) {
        ConjuntoLineal<int> pos_vieja = t.posiciones_por_palabra.obtener(vieja); // O(1)
        int #vieja = pos_vieja.tamaño(); // O(1)
        int #nueva = t.posiciones_por_palabra.obtener(nueva).tamaño(); // O(1)
        int #total = #vieja + #nueva; // O(1)
        Iterador<ConjuntoLineal<int>> it = new Iterador<ConjuntoLineal<int>>; // O(1)
        it = pos_vieja.iterador(); // O(1)
        while (it.hay_siguiente()) { // O(1)
            i = it.siguiente(); // O(1)
            t.palabras[i] = nueva; // O(1)
        } // O(k)
        
        t.posiciones_por_palabra.obtener(nueva).unir_rapido(pos_vieja); // O(1)

        if (#total > t.repeticiones_maxima) { // O(1)
            ConjuntoTrie<Palabra> conj = new ConjuntoTrie<int>; // O(1)
            conj = conj_vacio(); // O(1)
            conj.agregar(nueva); // O(1)
            t.repeticiones_maxima = #total; // O(1)
            t.palabras_mas_repetidas = conj; // O(1)
        } else if (#total == t.repeticiones_maxima) { // O(1)
            t.palabras_mas_repetidas.agregar(nueva); // O(1)
        }
    } // O(k)

    proc subtexto(in t: TextoImpl, in desde, hasta: int, out res: TextoImpl) {
        TextoImpl res = new TextoImpl; // O(1)
        res = nuevo_texto(); // O(1)
        for (i=desde..hasta inclusive) { // O(1)
            res.agregar_palabra(t.palabras[i]); // O(1)
        } // O(hasta - desde)
    } // O(hasta - desde)

    proc agregar_palabra(inout t: TextoImpl, p: Palabra) {
        if (!t.posiciones_por_palabra.está(palabra)) { // O(1)    
            ConjuntoLineal<int> conj = new ConjuntoLineal<int>; // O(1)
            conj = conj_vacio(); // O(1)
            conj.agregar(t.largo); // O(1)
            t.posiciones_por_palabra.definir(palabra, conj); // O(1)
            if (t.repeticiones_maxima == 0) { // O(1)
                t.repeticiones_maxima = 1; // O(1)
                t.palabras_mas_repetidas.agregar_rapido(palabra); // O(1)
            }
        } else {
            t.posiciones_por_palabra.obtener(palabra).agregar_rapido(t.largo); // O(1)
            if (t.posiciones_por_palabra.obtener(palabra).tamaño() > t.repeticiones_maxima) { // O(1)
                t.repeticiones_maxima = t.posiciones_por_palabra.obtener(palabra).tamaño(); // O(1)
                ConjuntoTrie<Palabra> conj = new ConjuntoTrie<int>; // O(1)
                conj = conj_vacio(); // O(1)
                conj.agregar(palabra); // O(1)
                t.palabras_mas_repetidas = conj;
            }
        }
        t.palabras.agregarAtras(palabra); // O(n)
        t.largo++; // O(1)
    } // O(1)
}

Esta estructura permite implementar todos los procs del TAD y con la eficiencia pedida donde fue especificada:
- masRepetidas es O(1) pues consiste en simplemente devolver la var palabras_mas_repetidas.
- subtexto es trivialmente O(hasta - desde) porque consiste simplemente en tomar el slice correspondiente del vector palabras y devolverlo.
- cambiarPalabra es O(k) pues consiste en:
    buscar ambas palabras involucradas en el DictTrie (O(1))
    modificar todas las posiciones de la palabra a ser cambiada en el array (O(k))
    según el caso:
        si la nueva palabra no está en el texto:
            crear nuevo elemento en el DictTrie para la palabra, usando al conjunto de la palabra cambiada como valor, y borrar el par asociado a la palabra cambiada (O(1))
        si la nueva palabra ya está en el texto:
            concatenar los conjuntos (O(1)) en la entrada del DictTrie para la palabra nueva, borrar el par asociado a la cambiada (O(1))
    si ahora cambió la palabra de maximas apariciones (o se tiene que agregar una al set), modificar tanto repeticiones_maxima como palabras_mas_repetidas de manera acorde (O(1))

12.1, 2, 3.
Modulo TorneoImpl implementa TAD Torneo {
    var equipos: ConjuntoAVL<Equipo>; // paralelo a obs equipos
    var partidos: ListaEnlazada<Partido, struct<goles_ganador: int, goles_perdedor: int>>; // paralelo a obs partidos, con struct extra para 12.3.
    var puntajes_por_equipo: DictAVL<Equipo, Puntaje>; // sirve para tener puntos en O(log(n))
    var posiciones_por_puntaje: DictAVL<Puntaje, struct<posición: Posición, cantidad: int>>; // posición, conjunto de equipos en esa posición; sirve para tener registrarPartido en O(log(n))
    // el conjunto de las últimas 2 vars da posicion en O(log(n))

    proc puntos(in t: TorneoImpl, in e: Equipo out res: int) {
        return t.puntajes_por_equipo.obtener(e); // O(log(n))
    } // O(log(n))

    proc posición(in t: TorneoImpl, in e: Equipo out res: int) {
        return t.posiciones_por_puntaje[t.puntajes_por_equipo.obtener(e)].posición; // O(log(n))
    } // O(log(n))

    proc registrarPartido(inout t: TorneoImpl, in ganador: Equipo, in perdedor: Equipo) {} // es un bardo, ver resuelto

    proc max_diferencia(in t: TorneoImpl, out res: Equipo) {
        int max = 0; // O(1)
        Equipo res = null; // O(1)
        Iterador<ListaEnlazada<Partido, struct<goles_ganador: int, goles_perdedor: int>>> it = new Iterador<ListaEnlazada<Partido, struct<goles_ganador: int, goles_perdedor: int>>>; // O(1)
        it = t.partidos.iterador(); // O(1)
        while(it.hay_siguiente()) { // O(1)
            <<Equipo, Equipo>, <int, int>> <<ganador, _>, <goles_ganador, goles_perdedor>> = it.siguiente(); // O(1)
            int diff = goles_ganador - goles_perdedor; // O(1)
            if (diff > max) { // O(1)
                max = diff; // O(1)
                res = ganador; // O(1)
            }
        } // O(#partidos)
        return res; // O(1)
    } // O(#partidos)
}

13.1, 2, 3.
Modulo SUECOimpl implementa TAD SUECO {
    var boletos: Vector<<Tiempo, Plata>>; // permite recuperar los obs, agregar_boleto en O(n)
    var cantidad_acumulada: DictAVL<Tiempo, int>; // permite obtener cantidad_intervalo en O(log(n)), y en agregar_boleto es modificable en O(n)
    var plata_acumulada: DictAVL<Tiempo, Plata>; // permite obtener plata_intervalo en O(log(n)), y en agregar_boleto es modificable en O(n)

    ...
}

agregar_boleto agrega el boleto (su info de tiempo y plata) al vector boletos (O(n)) y modifica cantidad_acumulada y plata_acumulada. 
Recorre ambos árboles in-order hasta encontrar o insertar donde corresponde al tiempo del boleto (con cantidad y plata 0, según el árbol). // O(n + log(n)) == O(n)
Suma 1/suma la plata del boleto a ese y todos los elementos que siguen, in-order (O(n)).
 
cantidad_intervalo busca inicio y fin en cantidad_acumulada (O(log(n))) y resta el valor de fin y el de inicio para obtener y devolver el resultado (O(1)).
